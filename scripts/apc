#!/bin/bash
# APC - Agentic Planning Coordinator CLI
#
# This script communicates with the APC daemon via WebSocket.
# The daemon is started by VS Code extension or can run standalone.

set -e

# Colors
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
GRAY='\033[0;90m'
BOLD='\033[1m'
RESET='\033[0m'

# Find workspace root (look for _AiDevLog or .git)
find_workspace_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/_AiDevLog" ]] || [[ -d "$dir/.git" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    echo "$PWD"
}

WORKSPACE_ROOT=$(find_workspace_root)
WORKING_DIR="$WORKSPACE_ROOT/_AiDevLog"

# Get script directory to find apc-ws-client.js
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WS_CLIENT="$SCRIPT_DIR/apc-ws-client.js"

# Check if ws client exists
if [[ ! -f "$WS_CLIENT" ]]; then
    echo -e "${RED}Error: WebSocket client not found at $WS_CLIENT${RESET}"
    echo -e "${YELLOW}Make sure the APC extension is properly installed.${RESET}"
    exit 1
fi

# Check for Node.js
if ! command -v node &> /dev/null; then
    echo -e "${RED}Error: Node.js is required but not installed.${RESET}"
    exit 1
fi

# Compute workspace hash (must match Node.js crypto)
WORKSPACE_HASH=$(printf "%s" "$WORKSPACE_ROOT" | md5 | cut -c1-8 2>/dev/null || printf "%s" "$WORKSPACE_ROOT" | md5sum | cut -c1-8)
PID_FILE="${TMPDIR:-/tmp}/apc_daemon_${WORKSPACE_HASH}.pid"
PORT_FILE="${TMPDIR:-/tmp}/apc_daemon_${WORKSPACE_HASH}.port"

# Check if daemon is running
is_daemon_running() {
    if [[ ! -f "$PID_FILE" ]]; then
        return 1
    fi
    local pid=$(cat "$PID_FILE" 2>/dev/null)
    if kill -0 "$pid" 2>/dev/null; then
        return 0
    fi
    return 1
}

# Get daemon port
get_daemon_port() {
    if [[ -f "$PORT_FILE" ]]; then
        cat "$PORT_FILE" 2>/dev/null
    else
        echo "19840"
    fi
}

# Send command via WebSocket client
send_ws_command() {
    local cmd="$1"
    local params="${2:-{}}"
    
    # Call the WebSocket client
    local result
    result=$(node "$WS_CLIENT" "$cmd" "$params" 2>&1)
    local exit_code=$?
    
    echo "$result"
    return $exit_code
}

# Display formatted response
display_response() {
    local response="$1"
    local success
    local data
    local error
    local message
    
    # Parse JSON response
    if command -v jq &> /dev/null; then
        success=$(echo "$response" | jq -r '.success // false')
        data=$(echo "$response" | jq -r '.data // empty')
        error=$(echo "$response" | jq -r '.error // empty')
        message=$(echo "$response" | jq -r '.message // empty')
    else
        # Fallback: basic grep parsing
        success=$(echo "$response" | grep -o '"success"[[:space:]]*:[[:space:]]*true' && echo "true" || echo "false")
        error=$(echo "$response" | grep -o '"error"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
        message=$(echo "$response" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
    fi
    
    if [[ "$success" == "true" ]]; then
        if [[ -n "$message" && "$message" != "null" ]]; then
            echo -e "${GREEN}✓ $message${RESET}"
        fi
        if [[ -n "$data" && "$data" != "null" && "$data" != "" ]]; then
            if command -v jq &> /dev/null; then
                echo "$data" | jq '.'
            else
                echo "$data"
            fi
        fi
        return 0
    else
        echo -e "${RED}✗ Error: ${error:-Unknown error}${RESET}"
        return 1
    fi
}

# Show progress while waiting for a long operation
show_progress() {
    local session_id="$1"
    local progress_file="$WORKING_DIR/Plans/$session_id/progress.log"
    local last_line=0
    local check_count=0
    local max_checks=1800  # 30 minutes at 1s intervals
    
    while [[ $check_count -lt $max_checks ]]; do
        if [[ -f "$progress_file" ]]; then
            local current_lines=$(wc -l < "$progress_file" 2>/dev/null | tr -d ' ' || echo "0")
            if [[ "$current_lines" -gt "$last_line" ]]; then
                tail -n +$((last_line + 1)) "$progress_file" 2>/dev/null | while IFS= read -r line; do
                    # Color code based on content
                    if [[ "$line" == *"PHASE"* ]] || [[ "$line" == *"═══"* ]]; then
                        echo -e "${CYAN}$line${RESET}"
                    elif [[ "$line" == *"✅"* ]] || [[ "$line" == *"Complete"* ]]; then
                        echo -e "${GREEN}$line${RESET}"
                    elif [[ "$line" == *"⚠️"* ]] || [[ "$line" == *"CONCERN"* ]]; then
                        echo -e "${YELLOW}$line${RESET}"
                    elif [[ "$line" == *"❌"* ]] || [[ "$line" == *"Error"* ]]; then
                        echo -e "${RED}$line${RESET}"
                    else
                        echo -e "${GRAY}$line${RESET}"
                    fi
                done
                last_line=$current_lines
            fi
        fi
        sleep 1
        check_count=$((check_count + 1))
    done
}

# Parse command
COMMAND="${1:-help}"
shift 2>/dev/null || true

case "$COMMAND" in
    status|s)
        echo -e "${CYAN}╔══════════════════════════════════════════════════════════╗${RESET}"
        echo -e "${CYAN}║  APC Status                                              ║${RESET}"
        echo -e "${CYAN}╚══════════════════════════════════════════════════════════╝${RESET}"
        echo ""
        
        if ! is_daemon_running; then
            echo -e "${YELLOW}⚠ Daemon is not running.${RESET}"
            echo -e "${GRAY}Start Cursor with the APC extension to start the daemon.${RESET}"
            exit 1
        fi
        
        response=$(send_ws_command "status" "{}")
        display_response "$response"
        ;;
    
    plan|p)
        SUB="${1:-list}"
        shift 2>/dev/null || true
        case "$SUB" in
            list|ls)
                echo -e "${CYAN}Planning Sessions:${RESET}"
                response=$(send_ws_command "plan.list" "{}")
                display_response "$response"
                ;;
            new|n|create)
                # Collect all remaining args as the prompt
                PROMPT="$*"
                # Parse --docs flag if present
                DOCS="[]"
                if [[ "$PROMPT" == *"--docs"* ]]; then
                    DOCS_STR=$(echo "$PROMPT" | sed 's/.*--docs //' | tr ' ' '\n' | grep -v '^--' | head -5 | tr '\n' ',' | sed 's/,$//')
                    DOCS="[$(echo "$DOCS_STR" | sed 's/\([^,]*\)/"\1"/g')]"
                    PROMPT=$(echo "$PROMPT" | sed 's/--docs.*//')
                fi
                if [[ -z "$PROMPT" ]]; then
                    echo -e "${RED}Usage: apc plan new \"<requirement>\" [--docs <path1> <path2>]${RESET}"
                    exit 1
                fi
                # Escape quotes in prompt
                PROMPT=$(echo "$PROMPT" | sed 's/"/\\"/g')
                
                echo -e "${CYAN}╔══════════════════════════════════════════════════════════╗${RESET}"
                echo -e "${CYAN}║  Starting Planning Session...                            ║${RESET}"
                echo -e "${CYAN}╚══════════════════════════════════════════════════════════╝${RESET}"
                echo ""
                
                response=$(send_ws_command "plan.create" "{\"prompt\": \"$PROMPT\", \"docs\": $DOCS}")
                display_response "$response"
                ;;
            status|st)
                ID="${1:-}"
                if [[ -z "$ID" ]]; then
                    echo -e "${RED}Usage: apc plan status <session_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "plan.status" "{\"id\": \"$ID\"}")
                display_response "$response"
                ;;
            revise|r)
                ID="${1:-}"
                shift 2>/dev/null || true
                FEEDBACK="$*"
                if [[ -z "$ID" ]] || [[ -z "$FEEDBACK" ]]; then
                    echo -e "${RED}Usage: apc plan revise <session_id> \"<feedback>\"${RESET}"
                    exit 1
                fi
                FEEDBACK=$(echo "$FEEDBACK" | sed 's/"/\\"/g')
                response=$(send_ws_command "plan.revise" "{\"id\": \"$ID\", \"feedback\": \"$FEEDBACK\"}")
                display_response "$response"
                ;;
            approve|a)
                ID="${1:-}"
                AUTOSTART="${2:-false}"
                if [[ -z "$ID" ]]; then
                    echo -e "${RED}Usage: apc plan approve <session_id> [--auto-start]${RESET}"
                    exit 1
                fi
                if [[ "$AUTOSTART" == "--auto-start" ]] || [[ "$AUTOSTART" == "-a" ]]; then
                    AUTOSTART="true"
                else
                    AUTOSTART="false"
                fi
                response=$(send_ws_command "plan.approve" "{\"id\": \"$ID\", \"autoStart\": $AUTOSTART}")
                display_response "$response"
                ;;
            cancel|c)
                ID="${1:-}"
                if [[ -z "$ID" ]]; then
                    echo -e "${RED}Usage: apc plan cancel <session_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "plan.cancel" "{\"id\": \"$ID\"}")
                display_response "$response"
                ;;
            *)
                echo -e "${YELLOW}Usage: apc plan [list|new|status|revise|approve|cancel]${RESET}"
                echo ""
                echo "  list              List all planning sessions"
                echo "  new \"<prompt>\"    Start new planning session"
                echo "  status <id>       Get session status"
                echo "  revise <id> \"..\" Revise plan with feedback"
                echo "  approve <id>      Approve plan for execution"
                echo "  cancel <id>       Cancel planning session"
                ;;
        esac
        ;;
    
    exec|e|run)
        SUB="${1:-status}"
        shift 2>/dev/null || true
        case "$SUB" in
            start|s)
                SESSION="${1:-}"
                if [[ -z "$SESSION" ]]; then
                    echo -e "${RED}Usage: apc exec start <session_id>${RESET}"
                    exit 1
                fi
                echo -e "${CYAN}Starting execution for $SESSION...${RESET}"
                response=$(send_ws_command "exec.start" "{\"sessionId\": \"$SESSION\"}")
                display_response "$response"
                ;;
            status|st)
                SESSION="${1:-}"
                if [[ -z "$SESSION" ]]; then
                    echo -e "${RED}Usage: apc exec status <session_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "exec.status" "{\"sessionId\": \"$SESSION\"}")
                display_response "$response"
                ;;
            pause|p)
                SESSION="${1:-}"
                if [[ -z "$SESSION" ]]; then
                    echo -e "${RED}Usage: apc exec pause <session_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "exec.pause" "{\"sessionId\": \"$SESSION\"}")
                display_response "$response"
                ;;
            resume|r)
                SESSION="${1:-}"
                if [[ -z "$SESSION" ]]; then
                    echo -e "${RED}Usage: apc exec resume <session_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "exec.resume" "{\"sessionId\": \"$SESSION\"}")
                display_response "$response"
                ;;
            stop|x)
                SESSION="${1:-}"
                if [[ -z "$SESSION" ]]; then
                    echo -e "${RED}Usage: apc exec stop <session_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "exec.stop" "{\"sessionId\": \"$SESSION\"}")
                display_response "$response"
                ;;
            *)
                echo -e "${YELLOW}Usage: apc exec [start|status|pause|resume|stop]${RESET}"
                echo ""
                echo "  start <id>    Start execution for approved plan"
                echo "  status <id>   Get execution status"
                echo "  pause <id>    Pause execution"
                echo "  resume <id>   Resume paused execution"
                echo "  stop <id>     Stop execution"
                ;;
        esac
        ;;
    
    workflow|wf)
        SUB="${1:-list}"
        shift 2>/dev/null || true
        case "$SUB" in
            list|ls)
                SESSION="${1:-}"
                if [[ -z "$SESSION" ]]; then
                    echo -e "${RED}Usage: apc workflow list <session_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "workflow.list" "{\"sessionId\": \"$SESSION\"}")
                display_response "$response"
                ;;
            status|st)
                SESSION="${1:-}"
                WORKFLOW="${2:-}"
                if [[ -z "$SESSION" ]] || [[ -z "$WORKFLOW" ]]; then
                    echo -e "${RED}Usage: apc workflow status <session_id> <workflow_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "workflow.status" "{\"sessionId\": \"$SESSION\", \"workflowId\": \"$WORKFLOW\"}")
                display_response "$response"
                ;;
            cancel|c)
                SESSION="${1:-}"
                WORKFLOW="${2:-}"
                if [[ -z "$SESSION" ]] || [[ -z "$WORKFLOW" ]]; then
                    echo -e "${RED}Usage: apc workflow cancel <session_id> <workflow_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "workflow.cancel" "{\"sessionId\": \"$SESSION\", \"workflowId\": \"$WORKFLOW\"}")
                display_response "$response"
                ;;
            *)
                echo -e "${YELLOW}Usage: apc workflow [list|status|cancel]${RESET}"
                ;;
        esac
        ;;
    
    pool)
        SUB="${1:-status}"
        shift 2>/dev/null || true
        case "$SUB" in
            status|st)
                response=$(send_ws_command "pool.status" "{}")
                display_response "$response"
                ;;
            resize|r)
                SIZE="${1:-}"
                if [[ -z "$SIZE" ]]; then
                    echo -e "${RED}Usage: apc pool resize <size>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "pool.resize" "{\"size\": $SIZE}")
                display_response "$response"
                ;;
            *)
                echo -e "${YELLOW}Usage: apc pool [status|resize]${RESET}"
                ;;
        esac
        ;;
    
    agent|a)
        SUB="${1:-pool}"
        shift 2>/dev/null || true
        case "$SUB" in
            pool|p)
                response=$(send_ws_command "agent.pool" "{}")
                display_response "$response"
                ;;
            roles|r)
                response=$(send_ws_command "agent.roles" "{}")
                display_response "$response"
                ;;
            release)
                AGENT="${1:-}"
                if [[ -z "$AGENT" ]]; then
                    echo -e "${RED}Usage: apc agent release <agent_name>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "agent.release" "{\"agentName\": \"$AGENT\"}")
                display_response "$response"
                ;;
            *)
                echo -e "${YELLOW}Usage: apc agent [pool|roles|release]${RESET}"
                ;;
        esac
        ;;
    
    unity|u)
        SUB="${1:-status}"
        shift 2>/dev/null || true
        case "$SUB" in
            status|st)
                response=$(send_ws_command "unity.status" "{}")
                display_response "$response"
                ;;
            compile|c)
                response=$(send_ws_command "unity.compile" "{}")
                display_response "$response"
                ;;
            test|t)
                MODE="${1:-editmode}"
                response=$(send_ws_command "unity.test" "{\"mode\": \"$MODE\"}")
                display_response "$response"
                ;;
            *)
                echo -e "${YELLOW}Usage: apc unity [status|compile|test]${RESET}"
                ;;
        esac
        ;;
    
    session|sess)
        SUB="${1:-list}"
        shift 2>/dev/null || true
        case "$SUB" in
            list|ls)
                response=$(send_ws_command "session.list" "{}")
                display_response "$response"
                ;;
            status|st)
                ID="${1:-}"
                if [[ -z "$ID" ]]; then
                    echo -e "${RED}Usage: apc session status <session_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "session.status" "{\"id\": \"$ID\"}")
                display_response "$response"
                ;;
            pause|p)
                ID="${1:-}"
                if [[ -z "$ID" ]]; then
                    echo -e "${RED}Usage: apc session pause <session_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "session.pause" "{\"id\": \"$ID\"}")
                display_response "$response"
                ;;
            resume|r)
                ID="${1:-}"
                if [[ -z "$ID" ]]; then
                    echo -e "${RED}Usage: apc session resume <session_id>${RESET}"
                    exit 1
                fi
                response=$(send_ws_command "session.resume" "{\"id\": \"$ID\"}")
                display_response "$response"
                ;;
            *)
                echo -e "${YELLOW}Usage: apc session [list|status|pause|resume]${RESET}"
                ;;
        esac
        ;;
    
    daemon|d)
        SUB="${1:-status}"
        shift 2>/dev/null || true
        case "$SUB" in
            status|st)
                if is_daemon_running; then
                    local port=$(get_daemon_port)
                    local pid=$(cat "$PID_FILE" 2>/dev/null)
                    echo -e "${GREEN}✓ Daemon is running${RESET}"
                    echo -e "  PID:  $pid"
                    echo -e "  Port: $port"
                    echo -e "  Workspace: $WORKSPACE_ROOT"
                else
                    echo -e "${YELLOW}⚠ Daemon is not running${RESET}"
                    echo -e "${GRAY}Run 'apc system run --headless' to start the daemon.${RESET}"
                fi
                ;;
            *)
                echo -e "${YELLOW}Usage: apc daemon [status]${RESET}"
                echo ""
                echo "  status    Check if daemon is running"
                echo ""
                echo -e "${GRAY}Use 'apc system run' to start the daemon.${RESET}"
                ;;
        esac
        ;;
    
    system|sys)
        SUB="${1:-help}"
        shift 2>/dev/null || true
        case "$SUB" in
            run|start)
                # Parse mode
                MODE="headless"
                DAEMON_PORT=""
                VERBOSE=""
                FORCE=""
                
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --headless|-h)
                            MODE="headless"
                            shift
                            ;;
                        --vscode|-v)
                            MODE="vscode"
                            shift
                            ;;
                        --interactive|-i)
                            MODE="interactive"
                            shift
                            ;;
                        --port|-p)
                            DAEMON_PORT="$2"
                            shift 2
                            ;;
                        --verbose)
                            VERBOSE="--verbose"
                            shift
                            ;;
                        --force|-f)
                            FORCE="--force"
                            shift
                            ;;
                        *)
                            shift
                            ;;
                    esac
                done
                
                echo -e "${CYAN}╔══════════════════════════════════════════════════════════╗${RESET}"
                echo -e "${CYAN}║  Starting APC Daemon (${MODE} mode)                       ${RESET}"
                echo -e "${CYAN}╚══════════════════════════════════════════════════════════╝${RESET}"
                echo ""
                
                # Check if daemon is already running (unless --force)
                if [[ -z "$FORCE" ]] && is_daemon_running; then
                    local port=$(get_daemon_port)
                    echo -e "${GREEN}✓ Daemon already running on port $port${RESET}"
                    echo -e "${GRAY}Use --force to restart${RESET}"
                    exit 0
                fi
                
                # Build the start script path
                START_SCRIPT="$SCRIPT_DIR/../out/daemon/start.js"
                
                if [[ ! -f "$START_SCRIPT" ]]; then
                    # Try relative to extension
                    START_SCRIPT="$(dirname "$SCRIPT_DIR")/out/daemon/start.js"
                fi
                
                if [[ ! -f "$START_SCRIPT" ]]; then
                    echo -e "${RED}Error: Daemon start script not found.${RESET}"
                    echo -e "${YELLOW}Make sure the extension is compiled: npm run compile${RESET}"
                    exit 1
                fi
                
                # Build command
                CMD="node \"$START_SCRIPT\" --$MODE"
                [[ -n "$DAEMON_PORT" ]] && CMD="$CMD --port $DAEMON_PORT"
                [[ -n "$VERBOSE" ]] && CMD="$CMD $VERBOSE"
                [[ -n "$FORCE" ]] && CMD="$CMD $FORCE"
                CMD="$CMD \"$WORKSPACE_ROOT\""
                
                echo -e "${GRAY}Starting: $CMD${RESET}"
                echo ""
                
                # Execute
                eval $CMD
                ;;
            
            stop)
                if ! is_daemon_running; then
                    echo -e "${YELLOW}Daemon is not running${RESET}"
                    exit 0
                fi
                
                local pid=$(cat "$PID_FILE" 2>/dev/null)
                echo -e "${CYAN}Stopping daemon (PID: $pid)...${RESET}"
                
                kill -TERM "$pid" 2>/dev/null
                
                # Wait for shutdown
                local count=0
                while is_daemon_running && [[ $count -lt 10 ]]; do
                    sleep 0.5
                    count=$((count + 1))
                done
                
                if is_daemon_running; then
                    echo -e "${YELLOW}Force killing daemon...${RESET}"
                    kill -9 "$pid" 2>/dev/null
                fi
                
                echo -e "${GREEN}✓ Daemon stopped${RESET}"
                ;;
            
            restart)
                echo -e "${CYAN}Restarting daemon...${RESET}"
                "$0" system stop 2>/dev/null || true
                sleep 1
                "$0" system run "$@"
                ;;
            
            *)
                echo -e "${YELLOW}Usage: apc system [run|stop|restart]${RESET}"
                echo ""
                echo "  run [options]     Start the daemon"
                echo "    --headless      Headless mode (automation, scripts)"
                echo "    --vscode        VS Code mode (extension integration)"
                echo "    --interactive   Interactive CLI mode (future)"
                echo "    --port <port>   Override port (default: 19840)"
                echo "    --force         Force restart if already running"
                echo "    --verbose       Enable verbose logging"
                echo ""
                echo "  stop              Stop the running daemon"
                echo "  restart           Restart the daemon"
                echo ""
                echo -e "${GREEN}Examples:${RESET}"
                echo "  apc system run --headless"
                echo "  apc system run --headless --port 19841"
                echo "  apc system stop"
                ;;
        esac
        ;;
    
    help|--help|-h|h)
        echo -e "${CYAN}╔══════════════════════════════════════════════════════════╗${RESET}"
        echo -e "${CYAN}║       ${BOLD}APC - Agentic Planning Coordinator${RESET}${CYAN}               ║${RESET}"
        echo -e "${CYAN}╚══════════════════════════════════════════════════════════╝${RESET}"
        echo ""
        echo "Usage: apc <command> [subcommand] [options]"
        echo ""
        echo -e "${GREEN}System:${RESET}"
        echo "  system run --headless     Start daemon (headless mode)"
        echo "  system run --vscode       Start daemon (VS Code mode)"
        echo "  system run --interactive  Start daemon (interactive mode)"
        echo "  system stop               Stop the daemon"
        echo "  system restart            Restart the daemon"
        echo "  daemon status             Check daemon status"
        echo ""
        echo -e "${GREEN}General:${RESET}"
        echo "  status              Show overall system status"
        echo ""
        echo -e "${GREEN}Planning:${RESET}"
        echo "  plan list           List all planning sessions"
        echo "  plan new \"<prompt>\" Start new planning session"
        echo "  plan status <id>    Get session status"
        echo "  plan revise <id>    Revise plan with feedback"
        echo "  plan approve <id>   Approve plan for execution"
        echo "  plan cancel <id>    Cancel planning session"
        echo ""
        echo -e "${GREEN}Execution:${RESET}"
        echo "  exec start <id>     Start execution"
        echo "  exec status <id>    Get execution status"
        echo "  exec pause <id>     Pause execution"
        echo "  exec resume <id>    Resume execution"
        echo "  exec stop <id>      Stop execution"
        echo ""
        echo -e "${GREEN}Workflows:${RESET}"
        echo "  workflow list <id>  List workflows for session"
        echo "  workflow status     Get workflow status"
        echo "  workflow cancel     Cancel a workflow"
        echo ""
        echo -e "${GREEN}Agents:${RESET}"
        echo "  pool status         Show agent pool status"
        echo "  pool resize <n>     Resize agent pool"
        echo "  agent roles         List available roles"
        echo "  agent release <n>   Release agent back to pool"
        echo ""
        echo -e "${GREEN}Unity:${RESET}"
        echo "  unity status        Unity control status"
        echo "  unity compile       Queue compilation"
        echo "  unity test <mode>   Queue tests (editmode/playmode)"
        echo ""
        ;;
    
    *)
        echo -e "${RED}Unknown command: $COMMAND${RESET}"
        echo "Use 'apc help' for available commands."
        exit 1
        ;;
esac
